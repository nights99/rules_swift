// Copyright 2018 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation

struct Dependency: Codable {
  var name: String = ""
  var url: String = ""
  var version: String = ""
  var path: String = ""
  var dependencies: [Dependency]?
}
struct Dependency2: Codable {
  var name: String?
  // var url: String
  var guid: String?
  var type: String?
  var dependencies: [Dependency2]?
}
struct Dependency3: Codable {
  var contents: Dependency2?
}
// Current directory 
let cwd = URL(fileURLWithPath: FileManager.default.currentDirectoryPath)

// Current repository name
let repositoryName = CommandLine.arguments[1]
// Swift executable path that provided by bazel
let swiftPath = CommandLine.arguments[2]
let arPath = CommandLine.arguments[3]
// Build path where swift package manager puts all the artifacts
let buildPath = URL(fileURLWithPath: CommandLine.arguments[4], relativeTo: cwd)

let depgraphPath = URL(fileURLWithPath: "./depgraph.json", relativeTo: cwd);

let depgraphJson = try String(contentsOf: depgraphPath, encoding: .utf8).data(using: .utf8)
let dependencyGraph = try JSONDecoder().decode(Dependency.self, from: depgraphJson!)

let pifPath = URL(fileURLWithPath: "./pif.json", relativeTo: cwd);
let pifJson = try! String(contentsOf: pifPath, encoding: .utf8).data(using: .utf8)
let pifGraph = try! JSONDecoder().decode([Dependency3].self, from: pifJson!)

func generateBuildFile(_ dependency: Dependency) throws -> Void {
  print("Generating BUILD.bazel for \(dependency.name)")
  let dependencies = dependency.dependencies?.map { "\"@\(repositoryName)//\($0.name)\"" }
  let buildfileContent = 
    """
    # This file is automatically generated by swift_package_install rule please do not edit.
    # All rules in other repositories can use this target
    # Generated for \(dependency.name)@\(dependency.version)
    # Url: \(dependency.url)

    package(default_visibility = ["//visibility:public"])
    load("@build_bazel_rules_swift//swift:swift.bzl", "swift_import")

    swift_import(
      name = "\(dependency.name)",
      module_name = "\(dependency.name)",
      archives = [
        ":\(dependency.name).a",
      ],
      swiftmodule = 
        ":\(dependency.name).swiftmodule",
      swiftdoc = 
        ":\(dependency.name).swiftdoc",
      deps = [
        \((dependencies ?? []).joined(separator: ",\n"))
      ]
    )
    """

  let buildFilePath = URL(fileURLWithPath: "\(dependency.name)/BUILD.bazel", relativeTo: cwd);
  try! FileManager.default.createDirectory(atPath: dependency.name, withIntermediateDirectories: true, attributes: nil)

    try! buildfileContent.write(to: buildFilePath, atomically: true, encoding: .utf8);

  for dependency in dependency.dependencies ?? [] {
    try! generateBuildFile(dependency)
  }
}

func createModule(_ dependency: inout Dependency) throws -> Void {
  print("createModule for \(dependency.name)")
  let dependencyPath = URL(fileURLWithPath: dependency.name, relativeTo: cwd);
  // let dependencyPath = URL(fileURLWithPath: ".", relativeTo: cwd);
  try FileManager.default.createDirectory(atPath: dependencyPath.path, withIntermediateDirectories: true, attributes: nil)

  for f in try! FileManager.default.contentsOfDirectory(at: buildPath, 
      includingPropertiesForKeys: [URLResourceKey.nameKey, 
        // URLResourceKey.isRegularFileKey
        ]) {
    // if f.path.contains("CNIOAtomics") {
      print(f)
    // }
    if (f.path.hasSuffix(".swiftmodule") || f.path.hasSuffix(".build")) {
      do {
        try FileManager.default.copyItem(
          atPath: "\(buildPath.path)/\(f.path)", 
          toPath: "\(dependencyPath.path)/\(f.path)"
        )
      } catch {
        print("Error!: failed to copy \(buildPath.path)/\(f) to \(dependencyPath.path)/\(f.path) : \(error)")
      }
    }
  }

  do {
    try FileManager.default.copyItem(
      atPath: "\(buildPath.path)/\(dependency.name).swiftmodule", 
      toPath: "\(dependencyPath.path)/\(dependency.name).swiftmodule"
    )

    try FileManager.default.copyItem(
      atPath: "\(buildPath.path)/\(dependency.name).swiftdoc", 
      toPath: "\(dependencyPath.path)/\(dependency.name).swiftdoc"
    )
  } catch {
    print("Error!: \(error)")
  }
  do {
  try FileManager.default.createDirectory(atPath: "\(dependencyPath.path)/\(dependency.name).build", withIntermediateDirectories: true, attributes: nil)

    try FileManager.default.copyItem(
      atPath: "\(buildPath.path)/\(dependency.name).build/module.modulemap", 
      toPath: "\(dependencyPath.path)/\(dependency.name).build/module.modulemap"
    )
  } catch {
    print("Error!: \(buildPath.path)/\(dependency.name).build/module.modulemap \(error)")
  }
  var args = ["rcs", "\(dependencyPath.path)/\(dependency.name).a"];

  let allFiles = FileManager.default.enumerator(atPath: "\(buildPath.path)/\(dependency.name).build")
  let objectFiles = (allFiles?.allObjects as! [String])
      .filter{$0.hasSuffix(".o")}
      .map{"\(buildPath.path)/\(dependency.name).build/\($0)"}
  args += objectFiles

  let allFiles2 = FileManager.default.enumerator(atPath: "\(buildPath.path)/\(dependency.name).build/src")
  let objectFiles2 = (allFiles2?.allObjects as! [String])
      .filter{$0.hasSuffix(".o")}
      .map{"\(buildPath.path)/\(dependency.name).build/src/\($0)"}
  print("Foo: \(buildPath.path)/\(dependency.name).build/src \(objectFiles2)")
  args += objectFiles2


  let proc = Process()
  proc.executableURL = URL(fileURLWithPath: arPath)
  proc.arguments = args
  try proc.run()
  proc.waitUntilExit()

  for dependency in dependency.dependencies ?? [] {
    var dependency = dependency
    try createModule(&dependency)
  }
}

func buildPackage(_ dependency: Dependency) throws -> Void {
  let proc = Process()
  proc.executableURL = URL(fileURLWithPath: swiftPath)
  proc.arguments = ["build", "-c", "release", "--target", dependency.name, "-Xcc", "--sysroot=/nobackup/jnightin/crash-initrd/xr-deps/sysroots/os-infra/os-proj-pi-sdk/WRL9/x86_64/sysroot"]
  // proc.arguments = ["build", "-c", "release", "--target", "foo", "-Xcc", "--sysroot=/nobackup/jnightin/crash-initrd/xr-deps/sysroots/os-infra/os-proj-pi-sdk/WRL9/x86_64/sysroot"]
  try proc.run()
  proc.waitUntilExit()
}

// for dependency in dependencyGraph.dependencies! {
for dependency in pifGraph[2].contents!.dependencies! {
  var dep : Dependency = Dependency()
  // print("Components: \(String(describing: dependency.guid?.components(separatedBy: [":","@"])))")
  dep.name = (dependency.guid?.components(separatedBy: [":","@"])[1])!

  let nestedDep = pifGraph.first(where: { (d1: Dependency3) -> Bool in (d1.contents!.name == dep.name) && (d1.contents!.type == "standard")})
  // print("nestedDep: \(String(describing: nestedDep))")
  var deps: [Dependency] = []
  for d1 in nestedDep?.contents?.dependencies ?? [] {
    var dep1 : Dependency = Dependency()
    dep1.name = (d1.guid?.components(separatedBy: [":","@"])[1])!
    deps.append(dep1)
    // print("Adding dep \(dep1.name)")
  }
  // print("Deps: \(deps)")
  // dep.dependencies = [Dependency(name: nestedDep!.contents!.name!)]
  dep.dependencies = deps
  // dep.dependencies = [Dependency(name: "foo")]
  var dependency = dep
  // var dependency = dependencyGraph.dependencies![0]
  // print("Building \(dependency.name) \(String(describing: dependency))")
  try buildPackage(dependency)
  try createModule(&dependency)
  try generateBuildFile(dependency)
}
